package dk.medicinkortet.notproduktion.namespaceoracle;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.apache.log4j.Logger;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import com.trifork.xmlquery.Namespaces;

import dk.medicinkortet.xmlschema.FmkNamespaces;

/**
 * NamespaceOracleGenerator is used to parse the xsd schema files in the project
 * and generate a property file that is used by the NamespaceOracle class for
 * retrieving the expected namespace prefix for the XML elements when mapping
 * JSON structures to XML structures.
 */
public class NamespaceOracleGenerator {
	private static final Logger log = Logger.getLogger(NamespaceOracleGenerator.class);

	private static final String FORMAT_DESCRIPTION = //
		" Generated by class " + NamespaceOracleGenerator.class.getName() + //
		"\n# Format: parentElementPrefix.parentElementLocalName.childElementLocalName=childElementPrefix";
	
	private Namespaces namespaces = FmkNamespaces.getNamespaces();
	
	/** Map: qName (with canonical prefix) => XsdType. */
	private Map<String, XsdType> typeMap = new HashMap<String, XsdType>();
	
	/** Map: qName (with canonical prefix) => XsdElement. */
	private Map<String, XsdElement> elementMap = new HashMap<String, XsdElement>();
	
	private String baseInputDirName;
	private String outputFilename;
	private Properties props;
	private int parsedFilesCount = 0;
	private int mappedNamespacesCount = 0;
	private Set<String> namespacesWithNoCanonicalPrefix = new HashSet<String>();
	
	public static void main(String[] args) {
		try {
			new NamespaceOracleGenerator("etc/schemas/", "target/NamespaceOracle-generated.properties").run();
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}
	
	public NamespaceOracleGenerator(String baseInputDirName, String outputFilename) {
		this.baseInputDirName = baseInputDirName;
		this.outputFilename = outputFilename;
	}
	
	public void run() throws Exception {
		long startTime = System.currentTimeMillis();
		
		System.out.println("Parsing xsd files from basedir: " + baseInputDirName);
		traverseFiles(new File(baseInputDirName));
		System.out.println(parsedFilesCount + " files parsed");
		
		createProperties();
		System.out.println("Mapped " + mappedNamespacesCount + " element namespaces");
		
		writeOutputFile(new File(outputFilename));
		System.out.println("Wrote file: " + outputFilename);

		long duration = System.currentTimeMillis() - startTime;
		System.out.println("Done in " + duration + " ms");
		
		if (namespacesWithNoCanonicalPrefix.size() > 0) {
			StringBuilder sb = new StringBuilder("A canonical prefix could not be found for the following namespaces:\n");
			for (String ns : namespacesWithNoCanonicalPrefix) {
				sb.append("  " + ns + "\n");
			}
			/*
			 *  It is possible that if this exception is thrown it is because you have defined a new name space and 
			 *  forgotten to declare it in dk.medicinkortet.xmlschema.FmkNamespaces
			 */
			throw new IllegalStateException(sb.toString());
		}
		
		if (mappedNamespacesCount == 0) {
			throw new IllegalStateException("No namespaces mapped");
		}
	}
	
	private void createProperties() {
		props = new Properties();
		
		for (XsdElement element : elementMap.values()) {
			createPropertiesForElement(element);
		}
	}

	private void createPropertiesForElement(XsdElement element) {
		element.setProcessed();
		
		if (element.getNamespace() != null && element.getName() != null && element.getType() != null) { 
			if (element.getType() != null) {
				for (XsdElement elm2 : element.getType().getElements()) {
					
					String prefix1 = namespaces.getPrefix(element.getNamespace());
					String prefix2 = namespaces.getPrefix(elm2.getNamespace());
					if (prefix1 != null && prefix2 != null) {
						String key = prefix1 + "." + element.getName() + "." + elm2.getName();
						props.put(key, prefix2);
						mappedNamespacesCount++;
						//System.err.println(key + "=" + prefix2);
						if (!elm2.isProcessed()) {
							createPropertiesForElement(elm2);
						}
					} else {
						if (prefix1 == null && element.getNamespace() != null) {
							namespacesWithNoCanonicalPrefix.add(element.getNamespace());
						}
						if (prefix2 == null && elm2.getNamespace() != null) {
							namespacesWithNoCanonicalPrefix.add(elm2.getNamespace());
						}
					}
				}
			}
		} else {
			log.warn("Incomplete element: " + element.getNamespace() + ":" + element.getName() + ", type=" + element.getType() + ", file=" + element.getFilename());
		}
	}

	private void traverseFiles(File f) throws SAXException, IOException, ParserConfigurationException {
		if (f.isFile() && f.getName().endsWith(".xsd")) {
//			System.out.println("Parsing file: " + f.getPath());
			parseXsdFile(f);
		} else if (f.isDirectory()) {
			for (File f2 : f.listFiles()) {
				traverseFiles(f2);
			}
		} else {
			log.debug("Skipping file: " + f.getAbsolutePath());
		}
	}

	private void writeOutputFile(File outputFile) throws IOException {
		outputFile.mkdirs();
		outputFile.delete();
		FileOutputStream fos = new FileOutputStream(outputFile);
		BufferedOutputStream bos = new BufferedOutputStream(fos);
		props.store(bos, FORMAT_DESCRIPTION);
	}

	public void parseXsdFile(File file) throws SAXException, IOException, ParserConfigurationException {
		//System.out.println("Parsing " + file.getAbsolutePath());
		
		SAXParserFactory factory = SAXParserFactory.newInstance();
		SAXParser saxParser = factory.newSAXParser();

		MyDefaultHandler handler = new MyDefaultHandler(file);
		saxParser.parse(file, handler);

		parsedFilesCount++;
	}

	class MyDefaultHandler extends DefaultHandler {
		private int nestedInGroups = 0;
		private Stack<XsdType> typeUnderDefinitionStack = new Stack<XsdType>();
		private Stack<XsdElement> elementUnderDefinitionStack = new Stack<XsdElement>();

		private com.trifork.xmlquery.Namespaces localNamespaces = FmkNamespaces.getNamespaces();
		private String targetNamespace;
		private final File file;
		
		public MyDefaultHandler(File file) {
			this.file = file;
		}
		
		@Override
		public void startElement(String uri, String _localName, String qName, Attributes attributes)
				throws SAXException {
			String localName = getLocalName(qName);
			//System.out.println("Start Element: " + localName);
	
			if (localName.equalsIgnoreCase("schema")) {
				createNamespaceMap(attributes);
			} else if (localName.equals("group")) {
				nestedInGroups++;
			} else if (localName.equals("element") && nestedInGroups == 0) {
				String elmLocalName = attributes.getValue("name");
				String typeQName = attributes.getValue("type");
				String ref = attributes.getValue("ref");

				XsdType elmType;
				XsdElement element = null;
				if (elmLocalName != null) {
					elmType = (typeQName == null ? null : getType(localNamespaces, targetNamespace, typeQName));

					if (!typeUnderDefinitionStack.isEmpty()) {
						// Create element and put into its surrounding parent
						element = new XsdElement(targetNamespace, elmLocalName, elmType);
						XsdType typeUnderDefinition = typeUnderDefinitionStack.peek();
						typeUnderDefinition.getElements().add(element);
					} else {
						// Top level element: Create/lookup in elementMap
						element = getElement(targetNamespace, elmLocalName, elmType);
					}
					element.setFilename(file.getPath());
				} else if (ref != null) {
					// Create/lookup in elementMap
					element = getElementFromQName(localNamespaces, targetNamespace, ref);
					
					if (!typeUnderDefinitionStack.isEmpty()) {
						// Put element into its surrounding type
						XsdType typeUnderDefinition = typeUnderDefinitionStack.peek();
						typeUnderDefinition.getElements().add(element);
					} else {
						log.warn("Does this make sense? Top-level element is defined by another top-level element: ref=" + ref + ", in file " + file.getPath());
					}
				} else {
					log.warn("Element does have name+type or ref: name=" + elmLocalName + ", type=" + typeQName 
						+ ", ref=" + ref + ", file=" + file.getPath());
				}
				
				elementUnderDefinitionStack.push(element);
				log.debug("  name=" + elmLocalName + ", type=" + typeQName + ", ref=" + ref);
			} else if (localName.equals("complexType") || localName.equals("simpleType")) {
				String name = attributes.getValue("name");
				XsdType type = getType(targetNamespace, name);
				typeUnderDefinitionStack.push(type);
				
				if (!elementUnderDefinitionStack.isEmpty()) {
					XsdElement parentElement = elementUnderDefinitionStack.peek();
					parentElement.setType(type);
				}
			}
		}
	
		@Override
		public void endElement(String uri, String _localName, String qName) throws SAXException {
			String localName = getLocalName(qName);
			//System.out.println("End Element: " + localName);
			
			if (localName.equals("group")) {
				nestedInGroups--;
			} else if (localName.equals("element") && nestedInGroups == 0) {
				elementUnderDefinitionStack.pop();
			} else if (localName.equals("complexType") || localName.equals("simpleType")) {
				typeUnderDefinitionStack.pop();
			}
		}
	
		private void createNamespaceMap(Attributes attributes) {
			for (int i=0; i<attributes.getLength(); i++) {
				String qName = attributes.getQName(i);
				String namespace = attributes.getValue(i);
				
				if (qName.startsWith("xmlns:")) {
					String prefix = qName.substring(6);
					localNamespaces.addNamespace(prefix, namespace);
					
					//System.out.println("  namespace: " + key + "=" + value);
				} else if (qName.equals("targetNamespace")) {
					targetNamespace = namespace; 
				}
			}
		}
	}

	private XsdType getType(String namespace, String name) {
		String canonicalPrefix = namespaces.getPrefix(namespace);
		String qName = canonicalPrefix + ":" + name; 
		XsdType type = typeMap.get(qName);
		if (type == null) {
			type = new XsdType(namespace, name);
			typeMap.put(qName, type);
		}
		return type;
	}

	private XsdType getType(com.trifork.xmlquery.Namespaces localNamespaces, String targetNamespace, String typeQName) {
		String typeLocalName = getLocalName(typeQName);
		String typePrefix = getPrefix(typeQName);
		String typeNamespace = (typePrefix == null ? targetNamespace : localNamespaces.get(typePrefix));
		
		return getType(typeNamespace, typeLocalName);
	}
	
	private XsdElement getElement(String namespace, String elmLocalName, XsdType elmType) {
		XsdElement element = getElement(namespace, elmLocalName);
		if (element.getType() != null && element.getType() != elmType) {
			log.warn("Type already set to something else for element '" + element + "' \n" //
					+ "old type: " + element.getType() + "\nnew type: " + elmType);
		}
		element.setType(elmType);
		return element;
	}

	private XsdElement getElement(String namespace, String elmLocalName) {
		String qName;
		qName = namespace + ":" + elmLocalName;
		XsdElement element = elementMap.get(qName);
		if (element == null) {
			element = new XsdElement(namespace, elmLocalName);
			elementMap.put(qName, element);
		}
		return element;
	}

	private XsdElement getElementFromQName(com.trifork.xmlquery.Namespaces localNamespaces, String targetNamespace, String qName) {
		String elmLocalName = getLocalName(qName);
		String elmPrefix = getPrefix(qName);
		String elmNamespace = (elmPrefix == null ? targetNamespace : localNamespaces.get(elmPrefix));
		
		return getElement(elmNamespace, elmLocalName);
	}
	
	
	private static String getLocalName(String qName) {
		int indexOfColon = qName.indexOf(':');
		if (indexOfColon >= 0) {
			String localName = qName.substring(indexOfColon + 1);
			return localName;
		}
		return qName;
	}
	
	private static String getPrefix(String qName) {
		int indexOfColon = qName.indexOf(':');
		if (indexOfColon >= 0) {
			String prefix = qName.substring(0, indexOfColon);
			return prefix;
		}
		return null;
	}
}
